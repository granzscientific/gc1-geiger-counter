substitutions:
  name: gs-gc1-geiger-counter
  friendly_name: "GS GC1 Geiger Counter"

  # See https://esphome.io/components/esphome.html#esphome-creators-project
  project_name: GranzScientific.GC1-Geiger-Counter
  project_ver_num: "1.0"
  project_ver_let: a

  # Multiplier to get uSv/Hour with SBM-20 tube is "0.00570"
  # Multiplier to get uSv/Hour with J305 tube is "0.00332"
  gm_tube_multiplier: "0.00570"
  # How often to read pulse counter and update status
  gm_update_interval: 1s
  # Number of samples to average: Multiply update_interval by this for total averaging period: 5s*5 = 25s
  gm_moving_avg_samples: "30"

esphome:
  project:
    name: ${project_name}
    version: ${project_ver_num}(${project_ver_let})
  name: ${name}
  friendly_name: ${friendly_name}
  platformio_options: # ESP32-C3 SuperMini options
    board_build.f_flash: 40000000L
    board_build.flash_mode: dio
    board_build.flash_size: 4MB
  on_boot:
    priority: -100 # only run after everything else is up and running
    then:
      - output.turn_on: boostctrl
      - output.ledc.set_frequency:
          id: boostctrl
          frequency: "490Hz"
      - output.set_level:
          id: boostctrl
          level: "10%"
      - rtttl.play: 'siren:d=8,o=5,b=100:d,e,d,e,d,e,d,e'

# ESP32 version and framework
esp32:
  variant: ESP32C3
  board: esp32-c3-devkitm-1
  framework:
    #type: esp-idf
    type: arduino

# https://esphome.io/components/esphome.html#adjusting-flash-writes
preferences:
  flash_write_interval: 5min

# Enable logging
logger:

# Enable Home Assistant API
api:
  id: gs_api
  # **** No API encryption key by default.  You should add one in your config!

# https://esphome.io/components/ota.html
ota:
  - platform: esphome
    # **** No OTA password by default.  You should add one in your config!
    on_error:
      - button.press: restart_button

wifi:
  id: wifi_wificomponent_id # For some reason, if any other id name is used this won't compile
  # Enable fallback access point (captive portal) in case wifi credentials missing
  ap:
    ssid: ${friendly_name}
    password: "12345678"
    # Disable AP when we have wifi credentials stored in nvmem
    # Note that, after a factory reset we still have an AP no matter what
    ap_timeout: 0s

web_server:
  port: 80
  local: true # Embed the web server data to allow it work without internet access
  ota: false  # Disables OTA through regular web interface

# Captive portal automatically enables web server OTA platform
# OTA will only be accessible when captive portal is active
captive_portal:

# Factory reset the device if power is cycled 5 times, with less than 5 seconds each time
# This clears WiFi credentials and allows the device to be setup again
# https://esphome.io/components/factory_reset/
factory_reset:
  resets_required: 5
  max_delay: 5s

# I2C bus
i2c:
  sda: GPIO2
  scl: GPIO1

# Buttons
button:
  # https://esphome.io/components/button/restart.html
  - platform: restart
    id: restart_button
    name: Restart Firmware
    entity_category: diagnostic

# Switches
switch:
  # Factory reset switch (clear wifi credentials, etc)
  - platform: factory_reset
    name: "Factory Reset"
  # Switch to power NTC to avoid battery drain when not being read
  - platform: gpio
    pin: GPIO3
    id: ntc_pwr
    internal: True # Hide from home assistant

# Configure the PWM outputs to drive the boost converter and the buzzer
# Note: We must specify channel to use for each output to avoid the buzzer out changing the boost converter frequency
output:
  - platform: ledc
    pin: GPIO4
    channel: 4
    id: boostctrl
  - platform: ledc
    pin: GPIO0
    channel: 0
    id: buzzer_out

# Enable the addressable RGB LED on GPIO8
light:
  - platform: neopixelbus
    type: GRB
    variant: WS2812
    pin: GPIO8
    num_leds: 1
    default_transition_length: 0.1s
    internal: True  # Don't expose this to Home Assistant
    name: "Ionizing Radiation Power Indicator"
    id: indicator_light

# Buzzer tone module
rtttl:
  output: buzzer_out
  id: buzzer
  gain: 50%

# Sensors
sensor:
  # ESP32 internal temperature sensor
  - platform: internal_temperature
    name: "MCU Internal Temperature"
    update_interval: 5s
  # BME680 air quality sensor
  - platform: bme680
    temperature:
      name: "BME680 Temperature"
      oversampling: 16x
    pressure:
      name: "BME680 Pressure"
    humidity:
      id: "humidity"
      name: "BME680 Humidity"
    gas_resistance:
      id: "gas_resistance"
      name: "BME680 Gas Resistance"
    address: 0x76
    update_interval: 5s
  - platform: template
    name: "BME680 Indoor Air Quality"
    id: iaq
    icon: "mdi:gauge"
    # calculation: comp_gas = log(R_gas[ohm]) + 0.04 log(Ohm)/%rh * hum[%rh]
    lambda: |-
      return log(id(gas_resistance).state) + 0.04 * id(humidity).state;
    state_class: "measurement"
  # Count pulses from GM tube
  - platform: pulse_counter
    pin:
      number: GPIO21
      inverted: false
    unit_of_measurement: 'uSv/Hour'
    name: 'Ionizing Radiation Power'
    count_mode:
      rising_edge: DISABLE
      falling_edge: INCREMENT
    update_interval: ${gm_update_interval}
    accuracy_decimals: 5
    id: dose_meter
    filters:
      - sliding_window_moving_average: # num-samples at update_interval above moving average here
          window_size: ${gm_moving_avg_samples}
          send_every: 1
      - multiply: ${gm_tube_multiplier}
    # Adjust the indicator LED based on current rad level
    on_value_range:
      - below: 0.25
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 20%
              red: 0%
              green: 100%
              blue: 0%
      - above: 0.26
        below: 0.50
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 20%
              red: 20%
              green: 80%
              blue: 0%
      - above: 0.51
        below: 0.75
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 30%
              red: 30%
              green: 70%
              blue: 0%
      - above: 0.76
        below: 1.00
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 40%
              red: 50%
              green: 50%
              blue: 0%
      - above: 1.01
        below: 1.25
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 50%
              red: 75%
              green: 25%
              blue: 0%
      - above: 1.26
        below: 1.5
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 60%
              red: 80%
              green: 20%
              blue: 0%
      - above: 1.51
        below: 2.00
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 80%
              red: 100%
              green: 0%
              blue: 0%
      - above: 2.01
        then:
          - light.turn_on:
              id: indicator_light
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
  # Integrate total dose
  - platform: integration
    name: "Total Ionizing Radiation Dose"
    unit_of_measurement: "uSv"
    sensor: dose_meter # link entity-id to the pulse_counter values above
    icon: "mdi:radioactive"
    accuracy_decimals: 5
    time_unit: min # integrate values every next minute
    filters:
      # Multiplier for total dose
      # To convert from uSv/hour to uSv/minute: (uSv/h / 60) = (uSv/h * 0.0166666667)
      # If dose_meter in CPM: (0.0057 / 60 minutes) = 0.000095; so CPM * 0.000095 = dose every next minute, uSv
      - multiply: 0.0166666667

# Air quality text description
text_sensor:
  - platform: template
    name: "BME680 IAQ Classification"
    icon: "mdi:checkbox-marked-circle-outline"
    lambda: |-
      if (int(id(iaq).state) <= 50) {
        return {"Excellent"};
      }
      else if (int(id(iaq).state) <= 100) {
        return {"Good"};
      }
      else if (int(id(iaq).state) <= 150) {
        return {"Lightly polluted"};
      }
      else if (int(id(iaq).state) <= 200) {
        return {"Moderately polluted"};
      }
      else if (int(id(iaq).state) <= 250) {
        return {"Heavily polluted"};
      }
      else if (int(id(iaq).state) <= 350) {
        return {"Severely polluted"};
      }
      else if (int(id(iaq).state) <= 500) {
        return {"Extremely polluted"};
      }
      else {
        return {"unknown"};
      }
